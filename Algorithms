###Mobus Inversion = 포함 배제 원리




###Burnside’s Lemma


###Graph Kernel & Centrality


 5. 트리 탐색

F(s) ; 평가함수
g(s) : 지금까지 소모한 비용
h(s) : 추정치

트리 탐색은 곧 F(s) = g(s)+h(s)에서 F(s)를 최소화하는 s를 탐색하는 문제이다.





원주율 스트링(그래프)

1.

3.14159265358979 ...에서 소수점 아래 숫자를 순서대로 배열에 저장할 때

배열 내 저장된 숫자와 저장된 위치가 일치하는 수는 무한한가?

2. 모든 숫자 x에 대해 주어진 숫자 x가 배열에 존재한 위치를 다음 그래프에 저장한다. 이 과정을 반복할 때 모든 수는 loop 위에 존재하는가?

3. 모든 수 x를 원주율 소숫점 아래 배열에서 찾을 수 있는가?



###DP
  DP는 Optimal Substructure를 지닌 Overlapping Subproblems를 D&C로 푸는 알고리즘 패러다임이다. Memoization/Caching(하향식)이나 Tabulation(상향식)으로 구현할 수 있다.

0. 문제 상황

 수열의 귀납적 정의는 수식은 깔끔하지만 재귀적으로 코드를 짜면 위험하다.
함수는 호출되면 스택에 데이터가 저장되고 실행 종료 시 해제된다. 즉 함수 호출에 의해 공간복잡도가 늘어나고 스택 오버플로우로 이어질 수 있다. 이를 Exponential Explosion이라고 한다.
그래서 어떤 배열을 선언하여 각 호출된 함수들을 미리 저장해두고 사용하는 방식으로 불필요한 호출 및 연산을 줄인다.

    int memo[100]{}; 
    int fibonacci(unsigned int n)
    {
      if (n<=1) 
        return 1;
      if (memo[n]!=0) 
        return memo[n]; 
      memo[n]=fibonacci(n-1) + fibonacci(n-2); 
      return memo[n];
    }
즉 구하고자 하는 수열 f(n)에 대해 O(n^2)이 O(f(n))으로 최적화된다.



 1. D&C와의 차이점과 용도

DP는 D&C와 달리 하위 문제에서 중복이 발생한다. 중복이 발생하기에 memo[n]가 위력을 발휘하는 것이다. 대표적으로 아래 문제에 쓰인다.

- 누적합
- LIS
- LCS
- 0-1 Knapsack
- 연쇄행렬곱
- Bellman-Ford, Floyd-Warshall




###Hierholzer’s Algorithm
  이 알고리즘은 O(|E|)로 오일러 경로의 모든 한붓그리기 방법을 탐색해준다.

 1. 아무 정점 v를 잡고 v에서 c로 돌아오는 경로를 탐색한다.

 2. 1.의 경로에서 지나지 않은 정점이 있다면 그 정점과 인접한 1. 경로 위 정점 u를 잡는다.

 3. u에서 u로 돌아오는 경로를 탐색하고 경로 1.에 추가한다.
