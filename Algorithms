###Mobus Inversion = 포함 배제 원리

###  Kadane Algorithm BOJ1912, BOJ13398

a[0]부터 a[n-1]까지의 배열에 대해 다음과 같은 m[]을 생각해볼 수 있다.



m[0] = a[0]

m[1] = max(a[1], a[1]+a[0])

m[1] = max(a[2], a[2]+a[1], a[2]+a[1]+a[0])

m[3] = max(a[3], a[3]+a[2], a[3]+a[2]+a[1], a[3]+a[2]+a[1]+a[0])



그런데 각 배열마다 m[i]는 a[i]가 모든 부분에 더해져있기 때문에 

m[i] = max(m[i-1]+a[i], a[i])

라는 귀납적 관계가 성립한다. 따라서 dp로 구현하면



#include <stdio.h>

int max_of(int a,int b) //최댓값을 반환하는 함수 max(a,b)의 역할
{
    return (a>b) ? a:b; //삼항연산자
}

int main(){
        int n, m; // 입력개수 n, n개의 입력값 m -> ai의 역할
        scanf("%d", &n);
        int max= -999999, memo= 0; 
        // max : 최댓값; memo : m[i-1]의 역할, i-1번째 원소를 포함한 부분합의 최댓값을 나타냄
        
        for (int i=0; i<n; i++) { 
            scanf("%d", &m);
            memo= max_of(m, memo+m); // m[i]= max(m[i-1]+ai, ai) 를 나타낸 코드
            max= max_of(memo, max); // 기존의 최댓값과 비교
        }
        
        
        printf("%d",max);
}



memo[]로 메모이제이션을 구현해도 되지만 바로 전 값만 필요하다면 변수에 바로 저장하며 구할 수 있다.



 연속되지 않은 최대 부분합은 어떻게 구할 수 있을까?



#include <stdio.h>
#include <stdlib.h>
#define SIZE 100001
int a[SIZE]; // 입력값 저장
int left[SIZE];  
//[i]번째 값이 마지막이 되는 배열의 최대 부분합값을 저장하는 배열 m[]
int right[SIZE]; 
//[i]번째 값이 처음이 되는 배열의 최대 부분합값을 저장하는 배열 reverse_m[]

int n; // 입력개수
int max = -9999999;

int max_of(int a,int b) //최댓값을 반환하는 함수 max(a,b)의 역할
{
    return (a>b) ? a:b; //삼항연산자
}

int max_of_sum() //연속된 최대 부분합 반환하는 함수
{
    int sum=0; // 최대 부분합을 저장하는 변수
    sum= left[0]= a[0]; // 기본값을 처음 입력값으로 초기화

    for(int i=0; i<n; i++)
    {
        left[i]= max_of(left[i-1] + a[i], a[i]); 
        sum= max_of(sum, left[i]);
    }
    
    // 연속된 최대 부분합을 구하는 문제를 푸는 것과 동일하게 풀고, 그 값들을 left[] 에 저장한다.
   

    right[n] = a[n];
    for (int i=n-1; i>=0; i--)
    {
        right[i]= max_of(a[i], right[i+1] + a[i]);
    }
    // 동일하게 right[]에 들어갈 값들을 다 구하고, 저장한다. (방법은 동일하고 순서만 달라진다)
    
    
    for (int i=0;i<=n-2;i++)
    {
        sum= max_of(sum,left[i-1]+ right[i+1]);
    }
    // 연속된 경우의 최대합(sum)과 연속되지 않은 경우의 합을 하나하나 비교해준다.
    // 가장 큰값을 최종적으로 sum에 저장한다
    
  

    return sum; // sum 값 리턴

}
int main()
{
    scanf("%d", &n);
    for(int i=0; i<n; i++)
        scanf("%d", &a[i]);
    printf("%d", max_of_sum());
}




###Burnside’s Lemma


###Graph Kernel & Centrality


 5. 트리 탐색

F(s) ; 평가함수
g(s) : 지금까지 소모한 비용
h(s) : 추정치

트리 탐색은 곧 F(s) = g(s)+h(s)에서 F(s)를 최소화하는 s를 탐색하는 문제이다.





원주율 스트링(그래프)

1.

3.14159265358979 ...에서 소수점 아래 숫자를 순서대로 배열에 저장할 때

배열 내 저장된 숫자와 저장된 위치가 일치하는 수는 무한한가?

2. 모든 숫자 x에 대해 주어진 숫자 x가 배열에 존재한 위치를 다음 그래프에 저장한다. 이 과정을 반복할 때 모든 수는 loop 위에 존재하는가?

3. 모든 수 x를 원주율 소숫점 아래 배열에서 찾을 수 있는가?



###DP
  DP는 Optimal Substructure를 지닌 Overlapping Subproblems를 D&C로 푸는 알고리즘 패러다임이다. Memoization/Caching(하향식)이나 Tabulation(상향식)으로 구현할 수 있다.

0. 문제 상황

 수열의 귀납적 정의는 수식은 깔끔하지만 재귀적으로 코드를 짜면 위험하다.
함수는 호출되면 스택에 데이터가 저장되고 실행 종료 시 해제된다. 즉 함수 호출에 의해 공간복잡도가 늘어나고 스택 오버플로우로 이어질 수 있다. 이를 Exponential Explosion이라고 한다.
그래서 어떤 배열을 선언하여 각 호출된 함수들을 미리 저장해두고 사용하는 방식으로 불필요한 호출 및 연산을 줄인다.

    int memo[100]{}; 
    int fibonacci(unsigned int n)
    {
      if (n<=1) 
        return 1;
      if (memo[n]!=0) 
        return memo[n]; 
      memo[n]=fibonacci(n-1) + fibonacci(n-2); 
      return memo[n];
    }
즉 구하고자 하는 수열 f(n)에 대해 O(n^2)이 O(f(n))으로 최적화된다.



 1. D&C와의 차이점과 용도

DP는 D&C와 달리 하위 문제에서 중복이 발생한다. 중복이 발생하기에 memo[n]가 위력을 발휘하는 것이다. 대표적으로 아래 문제에 쓰인다.

- 누적합
- LIS
- LCS
- 0-1 Knapsack
- 연쇄행렬곱
- Bellman-Ford, Floyd-Warshall




###Hierholzer’s Algorithm
  이 알고리즘은 O(|E|)로 오일러 경로의 모든 한붓그리기 방법을 탐색해준다.

 1. 아무 정점 v를 잡고 v에서 c로 돌아오는 경로를 탐색한다.

 2. 1.의 경로에서 지나지 않은 정점이 있다면 그 정점과 인접한 1. 경로 위 정점 u를 잡는다.

 3. u에서 u로 돌아오는 경로를 탐색하고 경로 1.에 추가한다.
